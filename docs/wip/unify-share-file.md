# Unify Share File System

**Goals for Share Creation and Access**

Our primary goal is to establish a unified, secure, and user-friendly system for sharing files that maintains our zero-knowledge architecture. We aim to support sharing of files regardless of their original encryption method, ensuring a seamless experience for the owner and a simple experience for the recipient. The client application must handle the cryptographic complexity internally while presenting a clear and consistent interface to the user.

**The Three Password Types**

To avoid ambiguity, it is critical to distinguish between the three password types used in the system. First is the Account Password, which is the owner's main login password used to derive the Account Key. This key is used to encrypt the majority of user files, referred to as Account-Encrypted Files. Second is the Custom Password, which is an optional password set by the owner at the time of upload to encrypt a specific file. These Custom-Encrypted Files are not encrypted with the Account Key and require the specific custom password to be unlocked/decrypted. Third is the Share Password, which is a new, unique password explicitly chosen by the owner specifically when creating a share link. This is the password the recipient must enter to access the file. The Share Password is distinct from both the Account Password and the Custom Password.

**Unified Share Creation Workflow**

The share creation process is designed to be consistent for the owner regarding the output, which is always a secure link protected by a Share Password. When a user initiates a share, they are always required to explicitly set a Share Password for the recipient. The client application then performs the necessary cryptographic operations to create the share, which differs based on the source file's encryption.

For Account-Encrypted Files, the client application leverages the user's active session to make the process seamless. Since the user is logged in, their Account Key is already cached in memory. The client application uses this cached Account Key to silently decrypt the file's encryption key, then re-encrypts that key with the new Share Password set by the owner. This allows the owner to create shares without being prompted to re-enter their own credentials, providing a smooth user experience.

For Custom-Encrypted Files, the client application cannot automatically unlock the file because the encryption key is protected by a password that is not cached in the session. In this case, the client application must prompt the owner to enter the Original Custom Password for that specific file. Once the owner provides the correct password, the client application decrypts the file's encryption key and proceeds to re-encrypt it with the new Share Password. This ensures that even files with custom encryption can be shared securely, provided the owner can prove their authorization.

**Unified Share Access Workflow**

The experience for the recipient is designed to be secure, efficient, and identical regardless of the source file's encryption. When a recipient clicks a share link, their client application (browser or CLI) first downloads the Share Envelope, a small metadata package. The client then prompts the recipient to enter the Share Password. Upon entry, the client locally derives the Share Key and attempts to decrypt the Share Envelope using Authenticated Encryption (AES-GCM). This step serves two critical purposes: it verifies the password immediately without downloading the full file, and it reveals the File Encryption Key (FEK) and a unique Download Token. If decryption fails, the client notifies the recipient instantly. If successful, the client presents the decrypted Download Token to the server to authorize the transfer of the encrypted file content. This ensures that only a recipient with the correct password can consume server bandwidth. Finally, once the encrypted file is downloaded, the client uses the previously decrypted FEK to unlock the file content locally on the recipient's device. Notably, the share system does not require recipients to have an account or login in order to access shared files. They only need the link/ID/share password to download and decrypt a given shared file.

**Current State and Implementation Requirements**

The current implementation requires updates to align with this unified vision. For CLI users, the client interface needs to be updated to clearly distinguish between these flows. It must ensure that sharing Account-Encrypted files utilizes the cached keys where possible to avoid unnecessary prompts, while correctly prompting for the decryption password when sharing Custom-Encrypted files. (CLI tools need to be updated to create a secure way of caching the Account Key; TBD how to do this securely and safely on different Linux/BSD systems.)

For Web App users, the interface currently lacks the logic to intelligently handle these two scenarios. The share creation flow needs to be updated to check the file's encryption type. If the file is Account-Encrypted, it should use the cached Account Key to unlock the file silently. If the file is Custom-Encrypted, it must prompt the owner for the original password. In all cases, the UI must require the owner to set a Share Password for the recipient.

Once all the code changes are in place for the CLI clients, the Web App clients and in the code for the server itself, we can use dev-reset.sh to redeploy everything, and e2e-test.sh to test everything (at least for the CLI client portions). NOTE: We will need to update e2e-test.sh to make sure it aligns with the changes made to the app for the share system, and make sure that we have full end-to-end tests of sharing and decryption for both encrypted file types: Account Password-based and Custom Password-based. The tests should be done while logged out to simulate a non-user visitor/recipient without an account as well.

**Cryptographic Mechanics and Key Independence**

To ensure zero-knowledge security and data availability, the system utilizes a specific key management architecture based on File Encryption Keys (FEKs) and Key Envelopes. Every file is encrypted with a unique, random symmetric key called the FEK. This key is generated on the client side at the time of upload and is used to encrypt the actual file content. Crucially, the FEK never changes for the lifetime of the file version, regardless of how many times it is shared or who accesses it.

When the file is first uploaded, the FEK is encrypted using the owner's key (either the Account Key or Custom Password-derived Key). This creates the "Owner's Envelope," which is stored in the database. This envelope ensures that the owner can always decrypt the file using their own credentials.

When a share is created, the client application retrieves the Owner's Envelope and decrypts it to obtain the raw FEK. It then generates a new key derived from the Share Password (the Share Key) and encrypts the raw FEK (along with the Download Token) with this Share Key. This creates a new, separate "Share Envelope" which is stored alongside the share metadata.

It is vital to understand that creating a Share Envelope is a non-destructive additive process. It does *not* modify the original Owner's Envelope or the encrypted file content. The system simply stores an additional encrypted copy of the key. Therefore, the original owner retains full access to their file using their original password (Account or Custom), completely unaffected by the existence of the share or the Share Password. The owner's access path and the recipient's access path are cryptographically independent, meeting at the immutable FEK.

NOTE: The app will need to be updated to add in the Download Token feature, along with other changes to facilitate the intended design and functioning of the secure Share system.

---

## SHARED FILE LIFECYCLE

Here's the ideal end-to-end lifecycle of a shared file in Arkfile:

**Owner Upload and Encryption Phase**

When the owner uploads a file to Arkfile, the encryption process begins entirely on the client side to maintain the zero-knowledge architecture. The client first generates a unique random File Encryption Key (FEK) which is a symmetric key used exclusively for encrypting that specific file's content. The actual file data is then encrypted using this FEK with AES-256-GCM authenticated encryption, producing the encrypted file blob. Simultaneously, the file's metadata including the original filename and the SHA-256 hash of the original unencrypted file are also encrypted using the same FEK, each with their own unique nonces for security. The owner must choose how to protect this file by selecting either their Account Password or a Custom Password. If they choose the Account Password, the system derives an Account Key from their password using Argon2id with a deterministic salt based on their username, and this Account Key is used to encrypt the FEK, creating what's called the Owner's Envelope. If they choose a Custom Password instead, a separate Custom Key is derived from that password and used to encrypt the FEK. The encrypted file content, encrypted metadata (filename and SHA-256), the encrypted FEK (Owner's Envelope), and associated nonces are then uploaded to the server, which stores the encrypted file in S3-compatible storage and records all the encrypted metadata in the database. Critically, the server never sees the plaintext file content, the original filename, the original hash, the FEK itself, or any of the passwords used.

**Share Creation Phase**

When the owner decides to share a file with a friend, they initiate the share creation process which differs based on how the file was originally encrypted. The owner must always explicitly set a new Share Password that will be given to the recipient out of band. For Account-Encrypted files, the process is seamless because the owner is already logged in and their Account Key is cached in memory in their browser session. The client application silently uses this cached Account Key to decrypt the Owner's Envelope and extract the raw FEK without prompting the owner for any credentials. For Custom-Encrypted files, however, the client cannot automatically access the FEK because the Custom Password is not cached in the session for security reasons. In this case, the client must prompt the owner to re-enter the Original Custom Password for that specific file, then derives the Custom Key from it and decrypts the Owner's Envelope to obtain the FEK. Once the FEK is obtained through either path, the client generates a cryptographically random 32-byte Download Token and computes its SHA-256 hash. The client then creates a Share Envelope by taking the raw FEK and the Download Token, packaging them together, and encrypting this package using a Share Key derived from the Share Password the owner just set via Argon2id with a random salt. This Share Envelope, along with the salt and the Download Token hash, is sent to the server. The server generates a cryptographically secure 256-bit Share ID, stores the Share Envelope, salt, and Download Token hash in the database, and returns a share URL to the owner. The owner then shares this URL and the Share Password with their friend through an out-of-band communication channel like a secure messaging app or in person.

**Recipient Access and Download Phase**

When the friend (recipient) receives the share link and Share Password, they visit the share URL in their browser without needing to create an account or log in to Arkfile. The client application first makes a request to fetch the Share Envelope metadata from the server using the Share ID embedded in the URL. The server performs validation checks including verifying the share exists, hasn't expired, and hasn't exceeded any access limits, then returns the encrypted Share Envelope and the salt to the client, along with the size of the encrypted file. The client then prompts the recipient to enter the Share Password that was provided to them out of band. Using this password and the salt, the client derives the Share Key locally using Argon2id with the same parameters used during share creation. The client attempts to decrypt the Share Envelope using this derived Share Key with AES-256-GCM authenticated encryption. If the password is incorrect, the authenticated decryption fails immediately and the client notifies the recipient without consuming any bandwidth or downloading the actual file. If the password is correct, the decryption succeeds and reveals the FEK and the Download Token. The client then makes a second request to download the actual encrypted file content, this time including the Download Token in an X-Download-Token HTTP header. The server validates this Download Token by computing its SHA-256 hash and comparing it in constant time against the stored hash in the database. If the token is valid, the server streams the encrypted file content from S3 storage to the client, potentially incrementing an access counter and invalidating the share if it has reached its maximum allowed downloads. 

Once the encrypted file is fully downloaded to the client, the client uses the previously decrypted FEK to decrypt the file content locally in the browser, also decrypting the filename and SHA-256 metadata so the recipient can verify file integrity and save it with the correct name. The decrypted file is then available to the recipient for download to their device.

**Share Revocation and Expiration Management**

The share system provides multiple mechanisms for controlling access lifecycle and ensuring that shared files can be revoked or expire under various conditions, all while maintaining a complete audit trail. When an owner creates a share, they can optionally set an expiration time measured in hours, which the server enforces by storing an expires_at timestamp in the database and checking it before allowing any access to the share metadata or file download. The owner can also optionally configure a maximum download limit by setting the max_accesses field, and the server tracks each successful download by incrementing the access_count atomically within a database transaction to prevent race conditions. 

When the access_count reaches the max_accesses limit, the share is immediately invalidated upon completion of that final download by setting the revoked_at timestamp to the current time and recording the revoked_reason as "max_downloads_reached", which cryptographically prevents any further access while preserving the complete share record for audit purposes. The owner retains full control over their shares and can manually revoke or invalidate any share at any time through both the web interface and CLI tools, which sets the revoked_at timestamp and records the revoked_reason as "owner_revoked", immediately terminating all access without deleting the historical record. 

When any share is accessed, the server performs a layered validation sequence: first verifying the share exists, then checking that revoked_at is NULL to ensure the share has not been invalidated, then verifying that expires_at is either NULL or still in the future, then confirming that max_accesses is either NULL or access_count is still below the limit, and finally validating the Download Token hash using constant-time comparison. If any of these checks fail, the server returns a specific, informative error message such as "share has been revoked", "share has expired", or "share download limit reached" rather than a generic "not found" error, improving the user experience while maintaining security. 

The revoked_at timestamp approach ensures that the download_token_hash remains intact in the database even after invalidation, providing forensic evidence for security audits and debugging while preventing any possibility of token reuse since the revocation check occurs before token validation. 

The owner can view all their shares including both active and revoked ones through a list shares interface in both the web app and CLI, seeing comprehensive metadata about each share including creation time, expiration status, access counts, revocation status, and revocation reason, allowing them to audit their complete sharing history and manage ongoing access. This revocation system with audit trails ensures that the owner maintains complete control over who can access their files and for how long, with multiple layers of protection against unauthorized or extended access beyond the intended sharing period.

**Key Security Properties**

Throughout this entire workflow, several critical security properties are maintained. The server never has access to any plaintext data, passwords, or encryption keys. The FEK remains constant for the file's lifetime and is never re-encrypted or modified, only wrapped in different envelopes for different access paths. The Owner's Envelope and Share Envelope are cryptographically independent, meaning creating a share does not affect the owner's ability to access their own file with their original password. The Download Token system ensures that only recipients who successfully decrypt the Share Envelope can consume server bandwidth by downloading the encrypted file, preventing enumeration attacks and unauthorized downloads. Rate limiting based on privacy-preserving entity IDs protects against password guessing attacks on shares without logging IP addresses. The recipient never needs an account, preserving their privacy and anonymity. All password verification happens client-side through authenticated encryption, maintaining the zero-knowledge architecture where the server learns nothing about user data or access patterns beyond what's absolutely necessary for service operation.

This workflow represents the intended ideal design of the Arkfile File Sharing System.

