# Implementation Plan: Unified Share System (Final)

**Objective**: Implement a unified, Zero-Knowledge share workflow that supports both Account-Encrypted and Custom-Encrypted files. The system will enforce bandwidth protection via Download Tokens and provide a secure, consistent user experience across Web and CLI clients.

---

## Phase 1: Server-Side & Database
**Goal**: Enforce bandwidth protection using a unique Download Token for each share.

1.  **Database Schema Update**:
    *   **File**: `database/unified_schema.sql`
    *   **Action**: Add `download_token_hash` column (TEXT/VARCHAR) to the `file_share_keys` table (or active shares table).
    *   **Note**: Since this is a greenfield app, we will enforce this column as NOT NULL for new shares.

2.  **Share Creation Handler**:
    *   **File**: `handlers/file_shares.go`
    *   **Function**: `CreateFileShare`
    *   **Logic**:
        *   Accept `download_token_hash` in the JSON request body.
        *   Validate the hash is present.
        *   Store it in the database.

3.  **Share Download Handler**:
    *   **File**: `handlers/file_shares.go`
    *   **Function**: `DownloadSharedFile`
    *   **Logic**:
        *   Require `X-Download-Token` header in the request.
        *   Retrieve the stored `download_token_hash` for the share.
        *   Verify the provided token matches the hash (using constant-time comparison).
        *   Return `403 Forbidden` if missing or invalid.

---

## Phase 2: Core Crypto & Shared Logic
**Goal**: Standardize the Share Envelope format to ensure interoperability.

1.  **Share Envelope Structure**:
    *   Define a standard JSON structure for the *decrypted* content of the Share Envelope:
        ```json
        {
          "fek": "base64_encoded_fek",
          "download_token": "base64_encoded_token"
        }
        ```
    *   **Note**: The `download_token` is a random 32-byte value generated by the client.

2.  **Crypto Library Updates**:
    *   **Go (`crypto/`)**: Update envelope creation/parsing logic to support this JSON structure.
    *   **TypeScript (`client/static/js/src/crypto/`)**: Update `ShareEnvelope` handling to serialize/deserialize this JSON.

---

## Phase 3: Web Client (Browser)
**Goal**: Implement the Unified Workflow in the UI.

1.  **Share Creation Logic**:
    *   **Files**: `client/static/js/src/files/share-integration.ts`, `client/static/js/src/shares/share-creation.ts`
    *   **Workflow**:
        1.  **Detect Encryption Type**: Check if file is Account-Encrypted or Custom-Encrypted.
        2.  **Unlock FEK**:
            *   *Account-Encrypted*: Use cached `AccountKey` from session.
            *   *Custom-Encrypted*: Prompt user for `OriginalCustomPassword`. Derive key -> Decrypt Owner Envelope.
        3.  **Generate Share**:
            *   Generate random `DownloadToken` (32 bytes).
            *   Calculate `Hash(DownloadToken)`.
            *   Create JSON payload `{ fek, download_token }`.
            *   Encrypt payload with `SharePassword` -> `ShareEnvelope`.
        4.  **Send to Server**: POST `ShareEnvelope` + `download_token_hash`.

2.  **Share Access Logic**:
    *   **File**: `client/static/js/src/files/download.ts` (or new share download handler)
    *   **Workflow**:
        1.  **Fetch Metadata**: Get Share Envelope (encrypted).
        2.  **Decrypt**: Prompt for `SharePassword` -> Decrypt Envelope -> Extract `FEK` and `DownloadToken`.
        3.  **Download**:
            *   Use `fetch` to request the file.
            *   Set header: `X-Download-Token: <base64_token>`.
        4.  **Decrypt File**: Use extracted `FEK` to decrypt file content in browser.

---

## Phase 4: CLI Client (`arkfile-client`)
**Goal**: Secure key management and unified workflow via an Agent.

1.  **Agent Subcommand**:
    *   **Command**: `arkfile-client agent`
    *   **Function**:
        *   Run as a background process (daemon).
        *   Listen on a Unix Domain Socket (e.g., `~/.arkfile/agent.sock`).
        *   Securely hold the `AccountKey` in memory.
        *   Provide an API for `arkfile-client` and `cryptocli` to request operations (or the key itself, if strictly scoped).
    *   **Security**: Ensure socket permissions are `0600` (owner only).

2.  **CLI Integration**:
    *   **Update `arkfile-client`**:
        *   On login, start the agent (if not running) and send the `AccountKey` to it.
        *   On logout, stop the agent (clearing memory).
    *   **Update `cryptocli`**:
        *   Add support for connecting to the agent socket to retrieve keys for decryption/encryption operations.

3.  **Unified Share Workflow**:
    *   Implement the same logic as the Web Client:
        *   Detect encryption type.
        *   Request key from Agent (for Account-Encrypted) or prompt user (for Custom-Encrypted).
        *   Generate Token/Hash and Envelope.

---

## Phase 5: Testing & Verification
**Goal**: Ensure robustness and security.

1.  **E2E Tests**:
    *   **Script**: `scripts/testing/e2e-test.sh`
    *   **Scenarios**:
        1.  **Share Account-Encrypted**: Verify seamless creation (using Agent) and successful download.
        2.  **Share Custom-Encrypted**: Verify password prompt and successful download.
        3.  **Access Control**: Verify download fails without valid `X-Download-Token`.
        4.  **Crypto Integrity**: Verify decrypted file matches original.

2.  **Deployment**:
    *   Use `dev-reset.sh` to rebuild and deploy all changes.

---

# ADDITIONAL CONSIDERATIONS, SUGGESTED EDITS & ADDITIONS BY ANOTHER LLM:

### **Add to Phase 1 (Database Schema Update):**

- Ensure `max_accesses` column exists in `file_share_keys` table (INTEGER, nullable)
- Add logic to increment `access_count` on each successful download
- Add logic to enforce `access_count < max_accesses` before allowing download

### **Add to Phase 2 (Share Envelope Structure):**

- Note: The Share Envelope replaces the current `encrypted_fek` field.
- Current implementation stores only encrypted_fek.
- New implementation stores encrypted JSON: { fek, download_token }

### **Add to Phase 3 (Web Client - Share Creation):**

- Add UI field for "Max Downloads" (optional, maps to max_accesses)
- FEK Unlocking Logic:
  * Account-encrypted files: Retrieve FEK using cached AccountKey
  * Custom-encrypted files: Prompt for original custom password, decrypt Owner Envelope to get FEK
- Hash algorithm: Use SHA-256 for download_token_hash

### **Add to Phase 3 (Web Client - Share Access):**

- Add decryptFileWithFEK() function to crypto/file-encryption.ts
  * Input: encrypted file blob, raw FEK (Uint8Array)
  * Output: decrypted file blob
  * Parse file header, extract nonce, decrypt chunks with FEK

### **Add to Phase 4 (CLI Client):**

- Add --max-downloads flag to share creation command
- Implement same Share Envelope logic as web client
- Use X-Download-Token header in download requests

### **Add to Phase 5 (Testing):**

- Test max_accesses enforcement (share expires after N downloads)
- Test access_count increments correctly
- Test download fails when max_accesses reached
- Test constant-time hash comparison (timing attack resistance)

### **Add in controls server side to ensure share expiration/invalidation happens as requested by the owner:**

- If owner at any time wishes, he may invalidate/force-expire the share
- If download count (access count) equals max accesses, we must immediately invalidate the share
- download_token should be either deleted or overwritten with a new random value to prevent further downloads (implementation TBD; please advise) at the time that the share is rendered invalid or expires

---
