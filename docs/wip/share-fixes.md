# Implementation Plan: Unified Share System (HUMAN + GEMINI 3.0 LLM PLAN)

**Objective**: Implement a unified, privacy-preserving share workflow that supports both Account-Encrypted and Custom-Encrypted files. The system will enforce bandwidth protection via Download Tokens and provide a secure, consistent user experience across Web and CLI clients.

---

## Phase 1: Server-Side & Database
**Goal**: Enforce bandwidth protection using a unique Download Token for each share.

1.  **Database Schema Update**:
    *   **File**: `database/unified_schema.sql`
    *   **Action**: Add `download_token_hash` column (TEXT/VARCHAR) to the `file_share_keys` table (or active shares table).
    *   **Note**: Since this is a greenfield app, we will enforce this column as NOT NULL for new shares.

2.  **Share Creation Handler**:
    *   **File**: `handlers/file_shares.go`
    *   **Function**: `CreateFileShare`
    *   **Logic**:
        *   Accept `download_token_hash` in the JSON request body.
        *   Validate the hash is present.
        *   Store it in the database.

3.  **Share Download Handler**:
    *   **File**: `handlers/file_shares.go`
    *   **Function**: `DownloadSharedFile`
    *   **Logic**:
        *   Require `X-Download-Token` header in the request.
        *   Retrieve the stored `download_token_hash` for the share.
        *   Verify the provided token matches the hash (using constant-time comparison).
        *   Return `403 Forbidden` if missing or invalid.

---

## Phase 2: Core Crypto & Shared Logic
**Goal**: Standardize the Share Envelope format to ensure interoperability.

1.  **Share Envelope Structure**:
    *   Define a standard JSON structure for the *decrypted* content of the Share Envelope:
        ```json
        {
          "fek": "base64_encoded_fek",
          "download_token": "base64_encoded_token"
        }
        ```
    *   **Note**: The `download_token` is a random 32-byte value generated by the client.

2.  **Crypto Library Updates**:
    *   **Go (`crypto/`)**: Update envelope creation/parsing logic to support this JSON structure.
    *   **TypeScript (`client/static/js/src/crypto/`)**: Update `ShareEnvelope` handling to serialize/deserialize this JSON.

---

## Phase 3: Web Client (Browser)
**Goal**: Implement the Unified Workflow in the UI.

1.  **Share Creation Logic**:
    *   **Files**: `client/static/js/src/files/share-integration.ts`, `client/static/js/src/shares/share-creation.ts`
    *   **Workflow**:
        1.  **Detect Encryption Type**: Check if file is Account-Encrypted or Custom-Encrypted.
        2.  **Unlock FEK**:
            *   *Account-Encrypted*: Use cached `AccountKey` from session.
            *   *Custom-Encrypted*: Prompt user for `OriginalCustomPassword`. Derive key -> Decrypt Owner Envelope.
        3.  **Generate Share**:
            *   Generate random `DownloadToken` (32 bytes).
            *   Calculate `Hash(DownloadToken)`.
            *   Create JSON payload `{ fek, download_token }`.
            *   Encrypt payload with `SharePassword` -> `ShareEnvelope`.
        4.  **Send to Server**: POST `ShareEnvelope` + `download_token_hash`.

2.  **Share Access Logic**:
    *   **File**: `client/static/js/src/files/download.ts` (or new share download handler)
    *   **Workflow**:
        1.  **Fetch Metadata**: Get Share Envelope (encrypted).
        2.  **Decrypt**: Prompt for `SharePassword` -> Decrypt Envelope -> Extract `FEK` and `DownloadToken`.
        3.  **Download**:
            *   Use `fetch` to request the file.
            *   Set header: `X-Download-Token: <base64_token>`.
        4.  **Decrypt File**: Use extracted `FEK` to decrypt file content in browser.

---

## Phase 4: CLI Client (`arkfile-client`)
**Goal**: Secure key management and unified workflow via an Agent.

1.  **Agent Subcommand**:
    *   **Command**: `arkfile-client agent`
    *   **Function**:
        *   Run as a background process (daemon).
        *   Listen on a Unix Domain Socket (e.g., `~/.arkfile/agent.sock`).
        *   Securely hold the `AccountKey` in memory.
        *   Provide an API for `arkfile-client` and `cryptocli` to request operations (or the key itself, if strictly scoped).
    *   **Security**: Ensure socket permissions are `0600` (owner only).

2.  **CLI Integration**:
    *   **Update `arkfile-client`**:
        *   On login, start the agent (if not running) and send the `AccountKey` to it.
        *   On logout, stop the agent (clearing memory).
    *   **Update `cryptocli`**:
        *   Add support for connecting to the agent socket to retrieve keys for decryption/encryption operations.

3.  **Unified Share Workflow**:
    *   Implement the same logic as the Web Client:
        *   Detect encryption type.
        *   Request key from Agent (for Account-Encrypted) or prompt user (for Custom-Encrypted).
        *   Generate Token/Hash and Envelope.

---

## Phase 5: Testing & Verification
**Goal**: Ensure robustness and security.

1.  **E2E Tests**:
    *   **Script**: `scripts/testing/e2e-test.sh`
    *   **Scenarios**:
        1.  **Share Account-Encrypted**: Verify seamless creation (using Agent) and successful download.
        2.  **Share Custom-Encrypted**: Verify password prompt and successful download.
        3.  **Access Control**: Verify download fails without valid `X-Download-Token`.
        4.  **Crypto Integrity**: Verify decrypted file matches original.

2.  **Deployment**:
    *   Use `dev-reset.sh` to rebuild and deploy all changes.

---

# ADDITIONAL CONSIDERATIONS, SUGGESTED EDITS & ADDITIONS BY ANOTHER LLM (CLAUDE SONNET 4.5):

### **Add to Phase 1 (Database Schema Update):**

- Ensure `max_accesses` column exists in `file_share_keys` table (INTEGER, nullable)
- Add logic to increment `access_count` on each successful download
- Add logic to enforce `access_count < max_accesses` before allowing download

### **Add to Phase 2 (Share Envelope Structure):**

- Note: The Share Envelope replaces the current `encrypted_fek` field.
- Current implementation stores only encrypted_fek.
- New implementation stores encrypted JSON: { fek, download_token }

### **Add to Phase 3 (Web Client - Share Creation):**

- Add UI field for "Max Downloads" (optional, maps to max_accesses)
- FEK Unlocking Logic:
  * Account-encrypted files: Retrieve FEK using cached AccountKey
  * Custom-encrypted files: Prompt for original custom password, decrypt Owner Envelope to get FEK
- Hash algorithm: Use SHA-256 for download_token_hash

### **Add to Phase 3 (Web Client - Share Access):**

- Add decryptFileWithFEK() function to crypto/file-encryption.ts
  * Input: encrypted file blob, raw FEK (Uint8Array)
  * Output: decrypted file blob
  * Parse file header, extract nonce, decrypt chunks with FEK

### **Add to Phase 4 (CLI Client):**

- Add --max-downloads flag to share creation command
- Implement same Share Envelope logic as web client
- Use X-Download-Token header in download requests

### **Add to Phase 5 (Testing):**

- Test max_accesses enforcement (share expires after N downloads)
- Test access_count increments correctly
- Test download fails when max_accesses reached
- Test constant-time hash comparison (timing attack resistance)

### **Add in controls server side to ensure share expiration/invalidation happens as requested by the owner:**

- If owner at any time wishes, he may invalidate/force-expire the share
- If download count (access count) equals max accesses, we must immediately invalidate the share (on completion of the current download)
- download_token should be either deleted or overwritten with a new random value to prevent further downloads (implementation TBD; please advise) at the time that the share is rendered invalid or expires
- The owner should be able to list/view all the shares he has created at any time, and update them (delete/invalidate/extend) at any time from both the CLI and the Web App

---

# ADDITIONAL CONSIDERATIONS, SUGGESTED EDITS & ADDITIONS BY ANOTHER LLM (GPT-5.2):

## Key gaps / areas to improve

1. **Download endpoint is currently bypassable (bandwidth protection missing)**
   - `handlers/file_shares.go:DownloadSharedFile` currently requires only `share_id` (no `X-Download-Token`, no server-side gating), so an attacker can skip any ‚Äúpassword verification‚Äù flow and directly download encrypted bytes if they guess/obtain the share URL.
   - This is the central reason the Download Token design exists; it must be enforced server-side.

2. **Account-encrypted files cannot be shared in current implementation**
   - `CreateFileShare` explicitly blocks `passwordType == "account"` and requires the user to first add a custom password.
   - That conflicts with the ‚Äúunified‚Äù design where account-encrypted shares should use the cached AccountKey (web) / agent-held key (CLI).

3. **DB already has `access_count` / `max_accesses`, but handlers don‚Äôt enforce it**
   - `database/unified_schema.sql` includes `access_count` and `max_accesses` but `DownloadSharedFile` doesn‚Äôt check or increment them.
   - Any max-downloads feature should be enforced server-side with an atomic update (transaction) to avoid race conditions.

4. **Share access UI appears incomplete / inconsistent**
   - `client/static/shared.html` attempts to dynamically import `/js/dist/shares/share-access.js` and instantiate `ShareAccessUI`, but there is no corresponding TS source under `client/static/js/src/shares/`.
   - That suggests the recipient-side share flow (decrypt envelope, present token, download, decrypt file) is either missing or lives elsewhere.

5. **Share creation obtains FEK via a ‚Äúdownload‚Äù path (likely wrong primitive)**
   - `client/static/js/src/files/share-integration.ts:getFileInfo` calls `/api/files/<filename>/download` and expects JSON containing `encryptedFEK`.
   - A ‚Äúdownload‚Äù endpoint typically returns file bytes; FEK retrieval should be a separate metadata/key endpoint that returns the *owner envelope* (encrypted FEK) + `password_type` + any nonces needed.

6. **Server returns whole encrypted object base64-encoded in JSON**
   - `DownloadSharedFile` reads the entire object into memory (`io.ReadAll`) and returns base64 in JSON.
   - This will be a scalability and latency problem for large files, and it increases memory pressure and DOS risk. Prefer streaming bytes and letting the client decrypt as it downloads.

7. **Crypto format/versioning isn‚Äôt explicitly planned (yet)**
   - share-fixes.md proposes a decrypted JSON `{fek, download_token}` inside a ‚ÄúShare Envelope‚Äù.
   - You likely want an explicit envelope ‚Äúversion‚Äù + explicit KDF params included so old shares remain decryptable if Argon2 params change.

8. **Logging sensitivity**
   - The system is privacy-oriented; note that **share IDs are bearer secrets**. Logging full share IDs in plaintext is risky. Consider logging hashes/truncated IDs.

9. **Project-wide ‚Äúno emojis‚Äù rule**
   - `client/static/shared.html` contains a ‚ÄúüìÑ‚Äù icon. AGENTS.md says no emojis in code/docs/responses. Worth cleaning up to keep the repo consistent.

## 1. Preventing download bypass (must-have)
- The server must not allow downloading a shared file using only `share_id`.
- `DownloadSharedFile` must require an `X-Download-Token` header and verify it against `download_token_hash` using constant-time comparison.
- Treat missing/invalid tokens as `403 Forbidden` without revealing extra details.

## 2. Atomic enforcement of max-downloads / access_count
- If `max_accesses` is implemented, enforcement must be server-side.
- Use a transaction (or a single conditional UPDATE) to:
  1) verify `access_count < max_accesses` (or max is NULL),
  2) increment `access_count`,
  3) optionally invalidate the share when the limit is reached.
- Consider race conditions: concurrent downloads must not allow exceeding the max.

## 3. Share invalidation / revocation lifecycle
- Define a clear server-side ‚Äúrevoked/disabled‚Äù state for shares (recommended: `revoked_at`, `revoked_reason`, `deleted_at` or a boolean `is_active`).
- Owner must be able to revoke a share at any time (web + CLI).
- When a share expires or hits max downloads, it should be immediately invalidated.
- Prefer invalidation by deleting the row or marking it revoked (keeping an audit trail); do not rely on client-side behavior.

## 4. Streaming downloads (avoid base64-in-JSON for large files)
- Avoid `io.ReadAll` + base64 encoding for shared downloads.
- Prefer streaming the encrypted bytes as the HTTP response body (or implement chunked/ranged download) to reduce memory usage and improve performance.
- Ensure the recipient can still decrypt locally (the share envelope + FEK are enough).

## 5. Envelope format versioning and future-proofing
- Add an explicit envelope version and algorithm identifiers, for example:
  - `envelope_version`
  - `kdf: argon2id`
  - `argon2_params` used for that share (memory, iterations, parallelism)
  - `aead: aes-256-gcm`
- Consider using AEAD AAD to bind the envelope to `share_id` and/or `file_id` (prevents envelope swapping).

## 6. Client/server separation of responsibilities
- Share password verification remains client-side (privacy-preserving), but the server must enforce bandwidth protection (download token) regardless.
- Add a dedicated API for retrieving share envelope metadata vs downloading bytes. Avoid mixing ‚Äúdownload‚Äù and ‚Äúkey retrieval‚Äù semantics.

## 7. Rate limiting beyond password attempts
- Current `share_access_attempts` protects the password-guessing endpoint.
- Also rate limit the shared download endpoint (by share_id + entity_id) to mitigate bandwidth abuse even with correct tokens.

## 8. Observability without leaking bearer secrets
- Share IDs and download tokens are bearer secrets.
- Avoid logging full share IDs/tokens. Prefer truncated IDs or a one-way hash for correlation.

## 9. Web share recipient UI completeness
- Ensure there is a concrete recipient-side implementation that:
  1) fetches the encrypted Share Envelope,
  2) prompts for Share Password,
  3) decrypts envelope to obtain FEK + Download Token,
  4) downloads encrypted file using `X-Download-Token`,
  5) decrypts file locally.
- Verify `shared.html` imports a real built artifact (a TS source should exist for it).

---

# ADDITIONAL CONSIDERATIONS, SUGGESTED EDITS & ADDITIONS BY ANOTHER LLM (GROK-4.1-FAST):

## Phase 0: PREPARATION & CLEANUP (New)

2. **Logging Privacy:** Truncate share_id in all logs: `share_id=abc123...wxyz` (SHA256[:8]+[:4]).

3. **TS Build:** `bun run build` ‚Üí verify /js/dist/shares/share-access.js exists.

## Phase 1: Server/DB (Unique Enhancements)

1. **Schema (`unified_schema.sql` - Append):**
   ```
   ALTER TABLE file_share_keys ADD COLUMN download_token_hash TEXT NOT NULL DEFAULT '';
   ALTER TABLE file_share_keys ADD COLUMN revoked_at TIMESTAMP NULL;
   CREATE INDEX idx_file_share_keys_revoked ON file_share_keys(revoked_at);
   CREATE INDEX idx_file_share_keys_token_hash ON file_share_keys(download_token_hash);
   ```

2. **New Endpoint:** `GET /api/shares/{id}/envelope` ‚Üí `{salt_b64, encrypted_envelope_b64}` (rate-limited, check revoked_at/expires).

3. **DownloadSharedFile Tx (rqlite Atomic):**
   ```
   BEGIN TRANSACTION;
   SELECT access_count, max_accesses, revoked_at FROM file_share_keys WHERE share_id=? FOR UPDATE;
   -- Verify: revoked_at IS NULL AND (max_accesses IS NULL OR access_count < max_accesses)
   UPDATE file_share_keys SET access_count = access_count + 1;
   -- If access_count == max_accesses: SET revoked_at = CURRENT_TIMESTAMP;
   COMMIT;
   ```
   - Header `X-Download-Token` req'd; const-time SHA256(base64(token)) == hash.
   - **Stream:** `c.Stream(http.StatusOK, "application/octet-stream", object)` + `Content-Disposition: attachment; filename="shared-file.enc"`, `Content-Length: size_bytes`, `Accept-Ranges: bytes`.

4. **Rate-Limit Downloads:** entity_id + share_id in rate_limit_state.

## Phase 2: Crypto (Versioning Details)

1. **Envelope v1 (Unique Params):**
   ```json
   {"version":1,"kdf":"argon2id","kdf_params":{"memoryKiB":262144,"time":8,"parallelism":4},"aead":"AES-256-GCM","fek":"...","download_token":"..."}
   ```
   - AAD: `share_id + file_id`.

2. **Owner Endpoint:** `GET /api/files/{file_id}/envelope` (auth): `{password_type, encrypted_fek_b64, filename_nonce_b64, sha256sum_nonce_b64}`.

## Phase 3: Web (Missing Impl)

1. **share-integration.ts:** `getFileInfo` ‚Üí `/api/files/{file_id}/envelope`.

2. **ListShares UI:** Revoke btn ‚Üí `PATCH /api/shares/{id}/revoke` (set revoked_at).

## Phase 4: CLI (API Spec)

1. **Agent JSON-RPC:** `~/.arkfile/agent.sock`
   ```
   POST: {"jsonrpc":"2.0","method":"decryptOwnerEnvelope","params":{"type":"account|custom","envelope_b64":"...","pw_b64":"..."},"id":1}
   RESP: {"jsonrpc":"2.0","result":{"fek_b64":"..."},"id":1}
   ```

## Phase 5: Testing (Unique Scenarios)

1. **e2e-test.sh Add:**
   - Invalid/missing token ‚Üí 403 (no download).
   - Streaming large file (>100MB) ‚Üí no OOM, ranges work.
   - Revoke mid-flow ‚Üí 403.

---